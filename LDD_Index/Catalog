1. 第一章 设备驱动简介
1.1. 驱动程序的角色
1.2. 划分内核
1.2.1. 可加载模块
1.3. 设备和模块的分类
1.4. 安全问题
1.5. 版本编号
1.6. 版权条款
1.7. 加入内核开发社团
1.8. 本书的内容
2. 建立和运行模块
2.1. 设置你的测试系统
2.2. Hello World 模块
2.3. 内核模块相比于应用程序
2.3.1. 用户空间和内核空间
2.3.2. 内核的并发
2.3.3. 当前进程
2.3.4. 几个别的细节
2.4. 编译和加载
2.4.1. 编译模块
2.4.2. 加载和卸载模块
2.4.3. 版本依赖
2.4.4. 平台依赖性
2.5. 内核符号表
2.6. 预备知识
2.7. 初始化和关停
2.7.1. 清理函数
2.7.2. 初始化中的错误处理
2.7.3. 模块加载竞争
2.8. 模块参数
2.9. 在用户空间做
2.10. 快速参考
3. 字符驱动
3.1. scull 的设计
3.2. 主次编号
3.2.1. 设备编号的内部表示
3.2.2. 分配和释放设备编号
3.2.3. 主编号的动态分配
3.3. 一些重要数据结构
3.3.1. 文件操作
3.3.2. 文件结构
3.3.3. inode 结构
3.4. 字符设备注册
3.4.1. scull 中的设备注册
3.4.2. 老方法
3.5. open 和 release
3.5.1. open 方法
3.5.2. release 方法
3.6. scull 的内存使用
3.7. 读和写
3.7.1. read 方法
3.7.2. write 方法
3.7.3. readv 和 writev
3.8. 使用新设备
3.9. 快速参考
4. 调试技术
4.1. 内核中的调试支持
4.2. 用打印调试
4.2.1. printk
4.2.2. 重定向控制台消息
4.2.3. 消息是如何记录的
4.2.4. 打开和关闭消息
4.2.5. 速率限制
4.2.6. 打印设备编号
4.3. 用查询来调试
4.3.1. 使用 /proc 文件系统
4.3.2. ioctl 方法
4.4. 使用观察来调试
4.5. 调试系统故障
4.5.1. oops 消息
4.5.2. 系统挂起
4.6. 调试器和相关工具
4.6.1. 使用 gdb
4.6.2. kdb 内核调试器
4.6.3. kgdb 补丁
4.6.4. 用户模式 Linux 移植
4.6.5. Linux 追踪工具
4.6.6. 动态探针
5. 并发和竞争情况
5.1. scull 中的缺陷
5.2. 并发和它的管理
5.3. 旗标和互斥体
5.3.1. Linux 旗标实现
5.3.2. 在 scull 中使用旗标
5.3.3. 读者/写者旗标
5.4. Completions 机制
5.5. 自旋锁
5.5.1. 自旋锁 API 简介
5.5.2. 自旋锁和原子上下文
5.5.3. 自旋锁函数
5.5.4. 读者/写者自旋锁
5.6. 锁陷阱
5.6.1. 模糊的规则
5.6.2. 加锁顺序规则
5.6.3. 细 -粗- 粒度加锁
5.7. 加锁的各种选择
5.7.1. 不加锁算法
5.7.2. 原子变量
5.7.3. 位操作
5.7.4. seqlock 锁
5.7.5. 读取-拷贝-更新
5.8. 快速参考
6. 高级字符驱动操作
6.1. ioctl 接口
6.1.1. 选择 ioctl 命令
6.1.2. 返回值
6.1.3. 预定义的命令
6.1.4. 使用 ioctl 参数
6.1.5. 兼容性和受限操作
6.1.6. ioctl 命令的实现
6.1.7. 不用 ioctl 的设备控制
6.2. 阻塞 I/O
6.2.1. 睡眠的介绍
6.2.2. 简单睡眠
6.2.3. 阻塞和非阻塞操作
6.2.4. 一个阻塞 I/O 的例子
6.2.5. 高级睡眠
6.2.6. 测试 scullpipe 驱动
6.3. poll 和 select
6.3.1. 与 read 和 write 的交互
6.3.2. 底层的数据结构
6.4. 异步通知
6.4.1. 驱动的观点
6.5. 移位一个设备
6.5.1. llseek 实现
6.6. 在一个设备文件上的存取控制
6.6.1. 单 open 设备
6.6.2. 一次对一个用户限制存取
6.6.3. 阻塞 open 作为对 EBUSY 的替代
6.6.4. 在 open 时复制设备
6.7. 快速参考
7. 时间, 延时, 和延后工作
7.1. 测量时间流失
7.1.1. 使用 jiffies 计数器
7.1.2. 处理器特定的寄存器
7.2. 获知当前时间
7.3. 延后执行
7.3.1. 长延时
7.3.2. 短延时
7.4. 内核定时器
7.4.1. 定时器 API
7.4.2. 内核定时器的实现
7.5. Tasklets 机制
7.6. 工作队列
7.6.1. 共享队列
7.7. 快速参考
7.7.1. 时间管理
7.7.2. 延迟
7.7.3. 内核定时器
7.7.4. Tasklets 机制
7.7.5. 工作队列
8. 分配内存
8.1. kmalloc 的真实故事
8.1.1. flags 参数
8.1.2. size 参数
8.2. 后备缓存
8.2.1. 一个基于 Slab 缓存的 scull: scullc
8.2.2. 内存池
8.3. get_free_page 和其友
8.3.1. 一个使用整页的 scull: scullp
8.3.2. alloc_pages 接口
8.3.3. vmalloc 和 其友
8.3.4. 一个使用虚拟地址的 scull : scullv
8.4. 每-CPU 的变量
8.5. 获得大量缓冲
8.5.1. 在启动时获得专用的缓冲
8.6. 快速参考
9. 与硬件通讯
9.1. I/O 端口和 I/O 内存
9.1.1. I/O 寄存器和常规内存
9.2. 使用 I/O 端口
9.2.1. I/O 端口分配
9.2.2. 操作 I/O 端口
9.2.3. 从用户空间的 I/O 存取
9.2.4. 字串操作
9.2.5. 暂停 I/O
9.2.6. 平台依赖性
9.3. 一个 I/O 端口例子
9.3.1. 并口纵览
9.3.2. 一个例子驱动
9.4. 使用 I/O 内存
9.4.1. I/O 内存分配和映射
9.4.2. 存取 I/O 内存
9.4.3. 作为 I/O 内存的端口
9.4.4. 重用 short 为 I/O 内存
9.4.5. 在 1 MB 之下的 ISA 内存
9.4.6. isa_readb 和其友
9.5. 快速参考
10. 中断处理
10.1. 准备并口
10.2. 安装一个中断处理
10.2.1. /proc 接口
10.2.2. 自动检测 IRQ 号
10.2.3. 快速和慢速处理
10.2.4. 实现一个处理
10.2.5. 处理者的参数和返回值
10.2.6. 使能和禁止中断
10.3. 前和后半部
10.3.1. Tasklet 实现
10.3.2. 工作队列
10.4. 中断共享
10.4.1. 安装一个共享的处理者
10.4.2. 运行处理者
10.4.3. /proc 接口和共享中断
10.5. 中断驱动 I/O
10.5.1. 一个写缓存例子
10.6. 快速参考
11. 内核中的数据类型
11.1. 标准 C 类型的使用
11.2. 安排一个明确大小给数据项
11.3. 接口特定的类型
11.4. 其他移植性问题
11.4.1. 时间间隔
11.4.2. 页大小
11.4.3. 字节序
11.4.4. 数据对齐
11.4.5. 指针和错误值
11.5. 链表
11.6. 快速参考

